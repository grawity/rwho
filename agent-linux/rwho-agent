#!/usr/bin/env perl
# rwho data collector daemon
use warnings;
no if $] >= 5.017011, warnings => qw(experimental::smartmatch);
use strict;
use 5.010;
use Getopt::Long qw(:config no_ignore_case bundling);
use JSON;
use LWP::UserAgent;
use POSIX qw(:errno_h :signal_h);
use Pod::Usage;
use Sys::Hostname;
use Time::HiRes qw(usleep);

my (%arg, %conf);

my $notify_url;
my $utmp_path;
my $poll_interval;
my $verbose	= 0;
my $do_fork	= 0;
my $do_single	= 0;
my $do_cleanup	= 0;
my $do_monitor	= 1;
my $do_poll	= 1;
my $skip_root	= 1;
my $skip_users;
my $only_users;
my $min_uid;
my $pidfile;
my $pidfile_h;

my $my_hostname;
my $my_fqdn;

my $monitor_impl;
my $main_pid;
my $poller_pid;

sub parse_bool {
	given (shift) {
		when (undef) { undef; }
		when (/^(yes|true)$/) { 1; }
		when (/^(no|false)$/) { 0; }
		default { warn "invalid boolean value '$_'\n"; undef; }
	}
}

sub parse_conf {
	my $fh = shift;
	map {split /\s*=\s*/, $_, 2}
	grep {length and !/^[#;]/}
	grep {chomp} <$fh>;
}

sub enum_sessions {
	my @utmp = ();
	if (eval {require User::Utmp}) {
		User::Utmp::utmpxname($utmp_path) if $^O eq 'linux';
		while (my $ent = User::Utmp::getutxent()) {
			if ($ent->{ut_type} == User::Utmp->USER_PROCESS) {
				next if !length $ent->{ut_user};
				push @utmp, {
					user => $ent->{ut_user},
					line => $ent->{ut_line},
					host => $ent->{ut_host},
					time => $ent->{ut_time},
				};
			}
		}
		User::Utmp::endutxent();
	}
	elsif (eval {require Sys::Utmp}) {
		my $utmp = Sys::Utmp->new(Filename => $utmp_path);
		while (my $ent = $utmp->getutent()) {
			if ($ent->user_process) {
				next if !length $ent->ut_user;
				push @utmp, {
					user => $ent->ut_user,
					line => $ent->ut_line,
					host => $ent->ut_host,
					time => $ent->ut_time,
				};
			}
		}
		$utmp->endutent();
	}
	else {
		die "error: either User::Utmp or Sys::Utmp required\n";
	}
	return @utmp;
}

# "utmp changed" handler
sub update {
	my @sessions = enum_sessions();
	for (@sessions) {
		$_->{uid} = scalar getpwnam $_->{user};
		$_->{host} //= "?";
		$_->{host} =~ s/^::ffff://;
	}
	if ($skip_root) {
		@sessions = grep {$_->{user} ne "root"} @sessions;
	}
	if ($skip_users) {
		@sessions = grep {$_->{user} !~ $skip_users} @sessions;
	}
	if ($only_users) {
		@sessions = grep {$_->{user} =~ $only_users} @sessions;
	}
	if ($min_uid) {
		@sessions = grep {$_->{uid} >= $min_uid} @sessions;
	}
	upload("put", \@sessions);
}

# Upload data to server
sub upload {
	my ($action, $sessions) = @_;
	my $ua = LWP::UserAgent->new;

	my %data = (
		host => $my_hostname,
		fqdn => $my_fqdn,
		opsys => $^O,
		action => $action,
		utmp => encode_json($sessions),
	);
	my $resp = $ua->post($notify_url, \%data);
	debug("upload: sending ".(scalar @$sessions)." entries");
	if (!$resp->is_success) {
		warn "upload: error: '".$resp->status_line."'\n";
	}
}

# Utility functions

sub debug {
	local $" = " ";
	$verbose and print "rwho-agent[$$]: @_\n";
}

sub getutmppath {
	my @paths = (
		"/run/utmp",		# Linux
		"/var/run/utmpx",	# NetBSD
		"/var/run/utmp",	# Linux (old)
		"/var/run/utx.active",	# FreeBSD
		"/var/adm/utmp",
		"/etc/utmp",
	);
	my ($path) = grep {-e} @paths;
	return $path;
}

sub forked (&) {
	my $sub = shift;
	my $pid = fork();
	if ($pid) {return $pid} else {exit &$sub}
}

sub daemonize {
	open(STDIN, "<", "/dev/null")
		or die "daemonize: cannot open /dev/null: $!\n";

	my $pid = fork;

	if (!defined $pid) {
		die "daemonize: cannot fork: $!\n";
	} elsif ($pid) {
		exit;
	} else {
		if (POSIX::setsid() < 0) {
			warn "daemonize: setsid failed: $!\n";
		}
		debug("running in background");
	}
}

sub canon_hostname {
	my $host = shift;
	if (eval {require Socket::GetAddrInfo}) {
		debug("canon_hostname: using Socket::GetAddrInfo");
		my %hint = (flags => Socket::GetAddrInfo->AI_CANONNAME);
		my ($err, @ai) = Socket::GetAddrInfo::getaddrinfo($host, "", \%hint);
		# FIXME: print error messages when needed
		return $err ? $host : ((shift @ai)->{canonname} // $host);
	}
	else {
		debug("canon_hostname: using \"getent hosts\"");
		open(my $fd, "-|", "getent", "hosts", $host);
		my @ai = split(" ", <$fd>);
		close $fd;
		return $ai[1] // $host;
	}
}

# Process management functions

sub fork_poller {
	$SIG{CHLD} = \&sigchld_reap_poller;
	return forked {
		$SIG{INT} = "DEFAULT";
		$SIG{TERM} = "DEFAULT";
		$SIG{CHLD} = \&sigchld_reap_any;
		exit(mainloop_poller());
	};
}

sub cleanup {
	if (defined $poller_pid) {
		debug("cleanup: killing poller");
		$SIG{CHLD} = \&sigchld_reap_any;
		kill(SIGTERM, $poller_pid);
	}
	debug("cleanup: removing sessions on server");
	upload("destroy", []);
	exit(0);
}

sub sigchld_reap_poller {
	my $pid = wait;
	$SIG{CHLD} = \&sigchld_reap_poller;
	if (defined $poller_pid and $pid == $poller_pid) {
		debug("poller exited, restarting");
		$poller_pid = fork_poller();
	} else {
		debug("received SIGCHLD for unknown pid $pid");
	}
}

sub sigchld_reap_any {
	my $pid = wait;
	$SIG{CHLD} = \&sigchld_reap_any;
	debug("received SIGCHLD for $pid");
}

# Main loops

sub mainloop_monitor_kqueue {
	IO::KQueue->import;
	open(my $ut, "<", $utmp_path)
		or die "error: cannot open utmp: $!\n";
	my $kq = IO::KQueue->new;
	$kq->EV_SET(fileno($ut), &EVFILT_VNODE,
		&EV_ADD | &EV_CLEAR, &NOTE_WRITE, 5);

	debug("monitor/kqueue: watching $utmp_path");
	while (1) {
		eval { $kq->kevent } or warn "$@";
		# hack for NetBSD to properly pick up changes
		usleep(50);
		update();
	}
	exit(0);
}

sub mainloop_monitor_inotify {
	Linux::Inotify2->import;
	my $inotify = Linux::Inotify2->new;
	$inotify->watch($utmp_path, &IN_MODIFY, \&update);

	debug("monitor/inotify: watching $utmp_path");
	while (1) {
		$inotify->poll;
	}
	exit(0);
}

sub mainloop_monitor {
	$0 = "rwho-agent: monitor";

	given ($monitor_impl) {
		when ("kqueue") { goto &mainloop_monitor_kqueue; }
		when ("inotify") { goto &mainloop_monitor_inotify; }
		default { die "error: monitor mode not supported on $^O\n"; }
	}
}

sub mainloop_poller {
	$0 = "rwho-agent: poller";

	debug("poller: updating every $poll_interval seconds");
	while (1) {
		sleep($poll_interval);
		update();
		if ($main_pid != $$ and !kill(0, $main_pid)) {
			warn "poller: lost main process, exiting\n";
			goto \&cleanup;
		}
	}
	exit(0);
}

# Initialization code

my $pod = "$0.1.pod";

$0 = "rwho-agent";

GetOptions(
	"config=s"	=> sub {
				my ($opt, $arg) = @_;
				if (open(my $fh, "<", $arg)) {
					%conf = parse_conf($fh);
				} else {
					die "error: unable to read '$arg' ($!)\n";
				}
			},
	"cleanup!"	=> \$do_cleanup,
	"daemon"	=> \$do_fork,
	"help"		=> sub { pod2usage(-input => $pod, -exitstatus => 0); },
	"include-root!"	=> sub { $arg{skip_root} = 0; },
	"man"		=> sub { pod2usage(-input => $pod, -exitstatus => 0, -verbose => 2); },
	"min-uid=i"	=> \$arg{min_uid},
	"monitor!"	=> \$do_monitor,
	"poll=i"	=> \$poll_interval,
	"no-poll"	=> sub { $poll_interval = 0; },
	"only-users=s"	=> \$arg{only_users},
	"pidfile=s"	=> \$pidfile,
	"server-url=s"	=> \$arg{notify_url},
	"skip-root!"	=> \$arg{skip_root},
	"skip-users=s"	=> \$arg{skip_users},
	"single!"	=> \$do_single,
	"v|verbose"	=> \$verbose,
) or pod2usage(-input => $pod, -exitstatus => 1, -verbose => 0);

# modules

if ($do_single) {
	$do_monitor = 0;
}

if ($do_monitor) {
	given ($^O) {
		when (/^(free|net|open)bsd$/) {
			eval {require IO::KQueue}
			or die "error: monitor enabled but IO::KQueue missing\n";
			$monitor_impl = "kqueue";
		}
		when ("linux") {
			eval {require Linux::Inotify2}
			or die "error: monitor enabled but Linux::Inotify2 missing\n";
			$monitor_impl = "inotify";
		}
		default {
			die "error: monitor enabled but OS '$^O' not supported\n";
		}
	}
	debug("monitor: using $monitor_impl on $^O");
}

# merge arguments and config file

$skip_root = $arg{skip_root}
		// parse_bool($conf{"agent.exclude_root"})
		// 1;

$skip_users = $arg{skip_users}
		// $conf{"agent.exclude_users"}
		// undef;

$skip_users = qr/^($skip_users)$/i if defined $skip_users;

$only_users = $arg{only_users}
		// $conf{"agent.include_users"}
		// undef;

$only_users = qr/^($only_users)$/i if defined $only_users;

$min_uid = $arg{min_uid}
		// $conf{"agent.min_uid"}
		// undef;

$notify_url = $arg{notify_url}
		// $conf{"agent.notify_url"}
		// "http://rwho.cluenet.org/server.php";

if (!length $notify_url) {
	die "server URL not specified\n";
}

debug("upload: using $notify_url");

$utmp_path = $conf{"agent.utmp_path"}
		|| getutmppath()
		|| die "error: utmp file not found\n";

$poll_interval //= ($do_monitor ? 600 : 30);

$do_poll = $poll_interval > 0;

unless ($do_monitor || $do_poll) {
	die "error: cannot disable both polling and monitor\n";
}

$my_hostname = $conf{"agent.hostname"}
		|| hostname()
		|| "(none)";

if ($my_hostname eq '(none)') {
	die "error: could not determine own hostname";
}

$my_fqdn = canon_hostname($my_hostname) || $my_hostname;

debug("identifying as \"$my_fqdn\" (hostname=\"$my_hostname\")");

# main code

if (defined $pidfile) {
	if ($do_single || $do_cleanup) {
		warn "warning: --pidfile ignored in single-update mode\n";
	} else {
		open($pidfile_h, ">", $pidfile)
			or die "unable to open pidfile '$pidfile'\n";
	}
}

chdir("/");

$SIG{INT} = \&cleanup;
$SIG{TERM} = \&cleanup;

if ($do_cleanup) {
	cleanup();
	exit(0);
} else {
	debug("performing initial update");
	update();
}

if ($do_fork) {
	if ($do_single) {
		warn "warning: --daemon ignored in single-update mode\n";
	} else {
		daemonize();
	}
}

$main_pid = $$;

if (defined $pidfile_h) {
	print $pidfile_h "$main_pid\n";
	close $pidfile_h;
}

if ($do_single) {
	exit(0);
} elsif ($do_monitor) {
	if ($do_poll) {
		$poller_pid = fork_poller();
	}
	exit(mainloop_monitor());
} elsif ($do_poll) {
	exit(mainloop_poller());
}
